		
		Building a REST API automation Framework from scratch for E2E testing using RestAssured, Cucumber BDD in a Maven project

			A) Create the Maven project with the RestAssure, Cucumber and Jackson-databind dependencies.
   1- Create the Maven project type quickstart in order to support Cucumber.
   
   2- Add the RestAssured and Cucumber .jar files into the project dependencies area of the pom.xml file.
   		Note: for the cucumber .jar file we must use the io.cucumber because it is an upgraded version of the info.cukes cucumber .jar and
   		      we need to add the .jar for "cucumber-java" and "cucumber-junit" BOTH OF THE SAME VERSION.
   		      - For the RestAssured .jar file make sure to use the one for io.rest-assured.

	3- Add dependency for the "jackson-databind.jar" file from "com.fasterxml.jackson.core " so that we can create pojo java classes for
	   Serialization and Deserialization.      
	   
    4- Download and install the "Cucumber Eclipse Plugin" or "Natural x.x" plugin to support all Cucumber editor validations in all "*.feature" files to be created.
    	Open the Help menu and click on "Eclipse Market Place"
    	Search for "natural" and click on Install. this will allow Eclipse to automatically validate all Gherkin commands in
    	all "*.feature" files. 	 
    	Note: We have to convert the project to a Cucumber project in order that the just installed Cucumber Editor can connect, through Ctrl+Rigt Mouse Click,
    	      the @Given, @When... in the .feature file to the corresponding code in the "StepsDefinition.java". to convert the file:
    	      Right click on the project name --> click on Configure --> click on "Convert to Cucumber Project"

    Note: in order to make sure that all added dependencies are included in the "Maven Dependencies" folder, open the "Project" sub-menu on top
          and make sure that the "Build Automatically" option is checked.  
          
           B) Define the project structure with Cucumber framework setup.
           		- Create the features package under src/test/java to hold all "*.feature" files
           		- Create the first .feature file: right click the features folder and click on
           		  		New --> File and provide the name you need with ".feature" extension ie: "placeValidations.feature"
           		  Note: keep in mind using variable while creating the scenarios so that we can reuse any "stepDefinition"
           		        implementation in multiple scenarios. example in a "When" instruction we can use the name of the API
           		        to use as variable (by putting it in "AddPlace") in this way we can the implemented code for another
           		        API using the same "post http request", this is:
           		        [When The client calls "AddPlace" API with post http request]
           		        [When The client calls "DeletePlace" API with post http request]
           		        Same is applicable for the "Then.."
           		        [And The "status" in the response body is "OK"]
           		   After creating this .feature file, which so far does not have any stepDefinition implemented, we can use a
           		   trick to automatically create the stepsDefinition file or java code. Go to the next section for the "trick"    
           		        		
           		- Create the stepDefinitions package under src/test/java to hold all "*.java" program to implement the .features. 
                      "trick": Run the new "*.feature" file and the error in the console will indicate that there is no 
                      stepDefinition for the "*.feature" file and automatically create one to solve the error, so we can copy it and paste it
                      when we create any "stepsDefinition" or .java class file. To run this empty .feature file first we have to create a 
                      "TestRunner.java" file, see below section.
                
                - Create TestRunner package with name "cucumber.Options" to store all the "TestRunner.java" programs.  
                  Create a .java class for all needed TestRunner.java file. Example 
				  ***[[[
						package cucumber.Options;						
						import org.junit.runner.RunWith;						
						import io.cucumber.junit.Cucumber;
						import io.cucumber.junit.CucumberOptions;
						
						@RunWith(Cucumber.class)
						@CucumberOptions(features="src/test/java/features",  //the whole folder, could also be specific .feature file: "src/test/java/features/placeValidatons.feature"
						                 glue= {"stepDefinition"})   //The package
						
						public class TestRunner {
						
						}
                    ]]]***
                        
           C) Create feature file with scenarios/testCases we want to automate.
           		See file: src/test/java/features/placeValidations210212.feature
           		          src/test/java/stepDefinitionsBackupPackage/StepsDefinition210212.java
           		          src/test/java/cucumber.Options/TestRunner210212.java
           
           D) Start Coding smart "Steps Definition" files or java program to implement the scenarios in the feature file.
           Smart "steps Definition" means that the code use parameters and Regular expressions in this way we can satisfy or can
           be used for  similar @Given, @When, @Then or @And.. steps in the scenarios, Example:
           In for one scenario in the .feature file:
           Scenario: Verify if a Place is Successfully Added using AddPlace API
					1	Given The AddPlace Payload
					2	When The client calls "add" API with post http request
					3	Then The API call is successful with status code 200
					4	And The "status" in the response body is "OK"
					5	And The "scope" in the response body is "APP"
					
           where line 4 and 5 can be implemented in the stepDefintion or java code using Regular expressions and parameters as:
           				@Then("The {string} in the response body is {string}")
						public void the_in_the_response_body_is(String parmJSONAttribute, String parmExpectedValue) {
						    // Convert the Raw Response to JSON so that we can access the attributes in the JSON response.
							String respInString = respnRaw.asString();
							JsonPath respInJson = new JsonPath(respInString);
							// Assert the expected value of the indicated JSON attribute in the Response received.
							assertEquals("** Indicated attribute:",parmExpectedValue, respInJson.get(parmJSONAttribute).toString());			 								    
						}
           
           Note: before running the TestRunning.java to execute the test, we have to make sure that the Junit.jar file is only once, either in
                 pom.xml file as dependency OR in the project --> "Java Built Path" --> Libraries for .jar files. This will avoid execution error. 
           
           E) Build Utility files to create all reusable code for all the API Request and Response specifications. 
              We have created the resources package in src/test/java and in it we created the "UtilityCodes.java" class. And because of this below
              changed were implemented in the "StepsDefinition.java" class:
		           1- In the class definition line, added : "extends UtilityCodes"
		              public class StepsDefinition extends UtilityCodes {  //By using "extends" we are making the UtilityCodes class the parent of the 
		              StesDefinition class, the advantage of this is that we can use, through INHERITANCE, all the methods in the UtilityCodes class 
		              without the need to create an object of type UtilityCodes class. this class is imported as "import resources.UtilityCodes;"
		              This is a good implementation because the UtilityCodes class will contains several reusable utility codes.
		           2- In the "@Given("The AddPlace Payload")"  using method "getCommonRequestSpecifications()" as inheritance from UtilityCodes" class.
		               requetSpec =
		           			given()
                            .spec(getCommonRequestSpecifications())  // Using specBuilder for the common code of the Request. the method getCommonRequestSpecifications()
                                                                // return a variable of type RequestSpecification.
           
           Note: the resources package must contain all the code related to the creation of the Framework.
           
           F) Build Pojo classes for Serialization and Deserialization of all JSON payloads. And modify all created programs to use the pojo.
           		The pojo classes must be created in a pojo package under src/main/java. Because the main if for reusable code and the
           		src/test/java should only contains code related to the test.
           		
           		In the resources package also created the TestDataBuilder.java class, to populate all data needed for the pojo creation. this 
           		contains below methods with it's functionalities:
           			getTheAddPlacePojo():
							//  1- This method: 
							//     1.1 Create an object of the pojo class AddPlace.java.
							//     1.2 Uses the pojo set methods to move the data to be used in the Serialization to build the JSON body for the AddPlace Request.
							//     1.3 Return the populated pojo postRequestBody of type AddPlace.java, which is used by RestAssured to build the JSON body during 
							//         the Serialization.  	
					           
           G) Implement "logging" to the Framework to log all API Request and Response details. 
           	  Creating a log is useful to see all the details execution about the Request payload, Response payload, Error generated, all messages
           	  displayed and more...
           	  The best place in code the logging or log file creation is in the Utility method "getCommonRequestSpecifications()" located in the 
           	  UtilityCodes.java at a GLOBAL level so that it can be used in each and every Request that is executed.
           	  To create the logging, in the getCommonRequestSpecifications() method, follow these steps:
           	  	1- insert this logging filter commands:
           	  	   .addFilter(RequestLoggingFilter.logRequestTo(stream))   //This logs all the API Requests executed. *** stream is an object of type PrintStream.
           	  	   .addFilter(ResponseLoggingFilter.logResponseTo(logFile)) //This logs all the API Responses returned.
           	  	2- To log to a separate file we have to create an object of type PrintStream (logFile) and then replace it by the stream argument in line 1, use
           	  	   this command to create the object logFile: "PrintStream logFile = new PrintStream(new FileOutputStream("logging.txt"));" below the method declaration, line 22
           	  	   the "logging.txt" file will be created at the level of the pom.xml file.
           	  	3- Replace the "stream" by "logFile" object.
           
           H) Create a "*.properties" file to include all Global variables and it's values and modify all the code to
              derive or use these Global variables from the *.properties file. This help to centralize the changes in 
              just one place. for example the RestAssured.BaseURI="https://RahulSettyAcademy.com" or any other.
              See method getGlobalProptValues(String parmProprty) in class UtilityCodes.java.
              
              	public static String getGlobalProptValues(String parmProprty) throws IOException {
		//Note: this method has been defined as "static" to allow to be used, in this class (see line #30), from other methods without the need to create an
		// object of this class. The other way to avoid creating object of a class is by making the class a parent of the calling class by using the
		// "extends" keyword in the calling class definition. 
		Properties proptyFile = new Properties();   // Dedine property file to be used.
		FileInputStream fileLocation = new FileInputStream("C:\\Eclipse\\Work_Area\\RestAssured_Maven_Cucumber_BDD_Framework_E2E\\src\\test\\java\\resources\\Global.properties");
		proptyFile.load(fileLocation);    //Load the file from the indicated location and make all property value availabe by using the getProperty() method.
		return proptyFile.getProperty(parmProprty); // Return the value of the proporty requested in the parmProprty.
	     }
               
           
           I) Implement Data Driven mechanism to derive/use data dynamically from Feature files in all the "stepsDefinition" files.           
               * 	Version 200215: Introduces DataDriven Scenario using Parameters ("<address>","<language>"..) so that we can run the Tests with multiple set of data And
 *                  reuse the same parameter in different @Given, @When, @Then, @And and @ But... To accomplish this we have to 
 *                  modify the code as follow:
 *                  	- Insert the parameter in the .feature file:
 *                  			+ Modify the Scenario command to include Outline, example "Scenario Outline:"
 *                  			+ Insert the needed parameters: "<name>" "<address>" "<language>" <accuracy>   
 *                                    Note: <accuracy> is of dataType "int" all the others are String because of enclosed in "" ("<address>").
 *                                    The parameters are indicated by using <> and the data type of each parameter is indicated by the use or 
 *                                    not use of the "", for example, "<xxx>" define as String, and <xxx> indicate numeric and then we can indicate as 
 *                                    int or double.
 *                  			+ Insert the values for each parameter in the created "Example:" section
 *                  				Example: 
										| name		| address			| language	| accuracy|
										|Juan Carlos|154 Apple Dr		|Spanish	|65       |
 *						- Run the TestRunner.java to generate the error then copy the suggested snippet code.
 *					    - Modify the affected @xxx name  with the copied snippet code and modify it to accept each one of the defined parameters.
 *						- To make the received parameters available to all methods define Global variable (wkXXXX) for each of then a populate them 
 *                        as soon as the parameters are received. 										
 *                  	- In the TestDataBuilder.java class, UPDATE, as needed, all methods to handled receiving data from the new parameters.
 *                  	  For example: setTheAddPlacePojo() to setTheAddPlacePojo(String parmName, String parmAddress, String parmLanguage, int parmAccuracy)		                
 *                      - Update the .body() commands to use the modified method: example .body(data.setTheAddPlacePojo(wkName, wkAddress, wkLanguage, wkAccuracy));

           J) Implement Parameterization to run all the tests with multiple data sets using the Cucumber "Examples"" keyword in 
              the "*.feature" file.
         *    After parameterization, to make the Scenario to run with MULTIPLE SET OF DATA we have to just insert additional lines in the "*.feature" file and 
 *            modify the SpecBuilder Utility method that create the logging.txt file (this is UtilityCodes.getCommonRequestSpecifications()) to create the log file
 *            only the first time it is executed (reqCommonSpecs == null) so that it accumulate the log for each data set ran. Following the code modifications:
 *             	- Insert the if (reqCommonSpecs == null) {}. to control the execution of the of enclosed code ONLY ONE TIME, this avoid replaced the created logging.txt file
	              every time that a request is executed, either by every new set of test data or RestAssured Request in the "StepsDefinition.java"
 *              - Change the variable for reqCommonSpecs as "public static", to indicate to Java Run Time environment to use a single instance of the reqCommonSpecs
                  variable throughout the entire execution of the StepsDefinition.java during the TestRunning.java running And making the value available to all programs/classes.
                  This is, before the first time running it will be == null after running, for any subsequence run, it will be change to NOT-null: 
 *             		+ public static RequestSpecification reqCommonSpecs; // defined as global to contain all the specifications that are common to all Requests. Also changed the 
 *                    other one "public static ResponseSpecification responseCommonSpecs;"
              
          
           K) Defining "Enum" class with constants to centralize all Request's Resources details (/maps/api/place/add/json) definition in el central
              location for easy of maintenance.
              Use "Enum" java class to define constants and methods to centralize the definition of all Request's HTTP method Resources details (/maps/api/place/add/json)
 *            in el central location for easy of maintenance:
 *                 	- In the resources package, create a new class for the Enum class with name APIHttpResourcesEnum.java to define all Resource constant needed and the 
 *                    constructor method: APIHttpResourcesEnum(String parmResource) and the getter method: getResource().
 *                  - In the StepsDefinition.java program, modify the @When method to use the "resource" constant defined Enum class:
			              + Create the object "reqstResource" of Enum type APIResource  and assign the value of the CONSTANT defined for APIName indicate in
				            the String parameter of this @When... method. And:
								  Modify the HTTP Request (.post(...) to use the getResource() method defined in the Enum class)
								  Modify the "*.feature" file to use the CONSTANTs defined in the Enum class.

           H) Develop "End To End" functionality tests with all validations and Assertions.
              		 Continue building the EndToEnd code by adding the use of the key (place_id) from the just added PLACE and the getPlaceAPI to 
					 verify that the data inserted matches the data provisioned as input in the "Examples: " section of the "*.feature" file. Using
					 the GetPlaceAPI. To implement this below was done:
					     - The Scenario in .feature file was modified with this validation: "And With created place_id and "GetPlaceAPI" verify returned name matches "<name>" provisioned"
					     - The corresponding code was created in the StepsDefinition.java under this method:
					           " @Then("With created place_id and {string} verify returned name matches {string} provisioned")
		                         public void with_created_place_id_and_verify_returned_name_matches_provisioned(String parmAPIName, String parmFromInputExpected) throws IOException {"					     
					     - Created the GENERIC method "getJsonAttributeValue(parmRespnse, parmAttributeName)" to get the value of any attribute from a
					       Response in JSON Raw format.
					     - Get the value of the just added "place_id" attribute, using the new GENERIC method.To be used in the GET Request.
					     - Prepare the global variable "requestSpec" to use the GetPlaceAPI Request using the method created for the @When.. keyword.
					       Adding a queryParameter to received the "place_id" value to search with the GET; as follow:
					            requetSpec = 
									given()
							           .spec(getCommonRequestSpecifications())
									   .queryParam("place_id", wkPlaceId);      						    
						  - Reuse the call API method created for the implementation of the @When keyword:
						    the_client_calls_api_with_request_http_method(parmAPIName, "GET"); the GET Http method is hard coded.
						  - Get the actual Value of the attribute to assert from the respnRaw and then assert it against the expected value from 
						    the Scenario "Examples:" section.
						  - Modified the validation implemented in "@Then("The {string} in the response body is {string}")" to use the 
						    new GENERIC method "getJsonAttributeValue(parmRespnse, parmAttributeName)"     
						                                                  
           M) Add more Tests and implement "Tagging" mechanism to run selected Tests from the "TestRunner.java" file. This is useful for
              selecting specific tests to run for Smoke test or Regression test:
              
            . Insert a new scenario for the new test "Delete Place" by only creating the @Given keyword and reusing existing @When, @Then, @And..:
	          	Scenario: Verify if the DeletePlace API functionality is working successfuly
				Given A valid DeletePlace Payload
				When The client calls "DeletePlaceAPI" API with "POST" request http method
				Then The API call is successful with status code 200
				And The "status" in the response body is "OK"	
			. Insert the code for @Given keyword into the StepsDefinition.java program.
			    - Created the DeletePlace.java pojo in the pojo package.
			    - Created the method setTheDeletePlacePojo(String parmPlaceId) in the TestDataBuilder.java class to Serialize the JSON Body Payload.
			    - Change the definition of the global variable wkPlaceId to be static. This will avoid it to be resetted to "null" when a Scenario
			      finish execution, and avoid the error: "java.lang.AssertionError: 1 expectation failed.
														 Expected status code <200> but was <404>." 
                  with the place_id empty in the Request body(): 														 
                  		Body:
							{ "place_id": "" }
				  and this message in the Response body():
				         	{  "msg": "Delete operation failed, looks like the data doesn't exists" }
			      static String wkPlaceId = ""; 
			    - Build the requetSpec for the RestAssured Request using "spec builder" and the serialized JSON payload. 
			    - This is all the code we have to implement because, setup the requetSpec for Delete, because all the other code for @When,
			      @Then, @And were already implemented in a smart way and just reused here.
				
			. Tagging mechanism allows to select which Scenario/Test we want to execute. to accomplish this, in the  from the "*.feature" 
			  file we have to add a tag @ScenarioName (example: @AddPlaceTest) before each scenario, then in the TestRunner.jave file, in the
			  Cucumber options, add the attribute: tags={"@ScenarioName1","@ScenarioName2",..."@ScenarioNameXYZ",}.
			  We can have multiple "*.feature" files in the features package; but TestRunner.java will execute only the @ScenarioName indicated
			  in the "tags" attribute, Example:
			  	   cumberOptions(features="src/test/java/features/placeValidations.feature", 
                                   glue= {"stepDefinitions"}             
				              //   ,tags= "@AddPlaceTest or @GetPlaceTest" )  // Execute Tests tagged with @AddPlaceTest OR @GetPlaceTest 
				              //   ,tags= "@AddPlaceTest and @GetPlaceTest" )  // Execute Tests tagged with BOTH "TOGETHER" @AddPlaceTest AND @GetPlaceTest
							       ,tags= "@AddPlaceTest or @GetPlaceTest or @Delete" )  // Execute Tests tagged with @AddPlaceTest OR @GetPlaceTest OR @Delete
				              //   ,tags= "@AddPlaceTest" )  // Execute Tests tagged with @AddPlaceTest
                    * // More documentation can be found at https://cucumber.io/docs/cucumber/api/
           
           N) Implement Pre (@Before()) and Pos (@After()) conditions for all tests using Cucumber Hooks.java class.
			  . Inserting Cucumber Hooks: 
			    The Hooks allow the definition of pre and pos conditions for the execution of selected Scenarios/Tests. This is helpful in the case that
			    we want to create the pre conditions for having independent execution of an Scenario/Test. Example if we try to run ONLY the @DeletePlace
			    scenario it will generate the error indicating that the "place_id" is null, because it is taken from memory after the execution of the
			    @AddPlaceTest. But by using Hooks we can send to execute the methods, in @AddPlaceTest, with constant/default values so that the 
			    "place_id" gets generated and be available for when the @DeletePlace runs independently. For this we have to:
			      - Create a Hooks.java class in the src/test/java/stepDefinitions package.
			      - Create methods to code the needed actions.
			        The code most be designed to create the needed preconditions/posconditions for the executing Scenario/Test. Example generating 
			            the static-global "wkPlaceId" key to be used by the @DeletePlace test.
			        And Include the smart code (IF) to control that the code can only be executed when the blocking condition is present, example
			            that the "place_id" == null, this is:   
	             					if (StepsDefinition.wkPlaceId==null) {
										// Use the methods in the StepsDefinition object to execute the needed steps.
										implementedStepsDef.the_add_place_payload_with_name_address_language_accuracy("Hector Lopez", "16 Main Street ", "korean", 58);
										implementedStepsDef.the_client_calls_api_with_request_http_method("AddPlaceAPI", "POST");
										implementedStepsDef.with_created_place_id_and_verify_returned_name_matches_provisioned("GetPlaceAPI", "Hector Lopez");
									}
			      - Tag the methods with Annontation @, indicating the @Before("@ScenarioTagName") for precondition  and @After("@ScenarioTagName") for pos-condition:
			           	@Before("@DeletePlace")
						public void beforeScenario() throws IOException {...} 
			      
			      Note: before and after running any Scenario/Test, Cucumber will automatically go to the Hooks.java file to execute any 
			            pre or pos conditions defined for the Scenario/Test. 
           
           
           O) Execute complete Framework from Maven command line.
              - Delete the AppTest.java class in package "cucumberBDD_Pkg.RestAssured_Maven_Cucumber_BDD_Framework_E2E" under src/tes/java, this was
                automatically created when building the project. By deleting this program will allows that when the Maven command (c:\ mvn test) is 
                executed it will search for the "TestRunner.java" program in the "cucumber.Options" package. This package name must be 
                exactly "cucumber.Options" for the TestRunner.java to be found.  
              - Get the path of the Maven project "C:\Eclipse\Work_Area\RestAssured_Maven_Cucumber_BDD_Framework_E2E" copy it.
              - Open a CMD prompt section and change to the folder of the copied path.
              - issue the commands: c:... "mvn compile" --> to compile only. compile is a "phase" in Maven.
           							
           							c:... "mvn test" --> The "test" Maven phase is used to compile and run. None file name is needed because it will run 
           							all the "TestRunner.java" in the "cucumber.Options" package, so we have to be careful in only placing in the the ones we want to execute. 
           							Make sure to copy the one we don't want to run in a backup package, see the cucumberOPtionsBackUp package. 
           							Also make sure that the "features" package only contains the .feature we want to execute all of the 
                					other moved to the featuresBackUp file.
                					
                					*** Filtering execution of Scenario using the cucumber.filter.tags="" using Maven parameter 
                					c:..\ mvn test -Dcucumber.filter.tags="(@GetPlaceTest or @DeleteTest) and not @saladTest"
                					c:..\ mvn test -Dcucumber.filter.tags="(@AddPlace or @DeleteTest)" //select scenarios having tags @AddPlace or @DeleteTest 
                					c:..\ mvn test -Dcucumber.filter.tags="@Regression or @DeleteTest" //select scenarios having tags @Regression or @DeleteTest
                					c:..\ mvn test -Dcucumber.filter.tags="@Regression and @GetPlaceTest" //select scenarios having both tags @Regression or @GetPlaceTest
                					c:..\ mvn test -Dcucumber.filter.tags="@Regression"   //select scenarios having tags @Regression
                					        "-D" is for indicating that a parameter is going to be indicated.
                					        "cucumber.filter.tags="" " used to override (replace or insert) the "tags" definition in the @CucumberOptions() of the
                					         "TestRunner.java" program.
                					        
                					c:... "mvn test -Dcucumber.options="--tags @GetPlaceTest" " --> ***** DEPRECATED after Cucumber version 6.******
                					        -D is for indicating that a parameter is going to be indicated. 
                					        cucumber.options="--tags @GetPlaceTest" is the parameter and value passed. See notes.
                					*** Note: While testing for learning the use of the "tags" option while running from Maven, it was found out
                					          that the tags IS NOT working because the execution was always driven by what was indicated in the
                					          "tags" active in the "TestRunner.java". The reason is that with Cucumber v6 and onwards you can no longer use
                					           cucumber.options with a command line like string. Instead you'll have to use individual properties:
                                                  "   mvn test -Dcucumber.filter.tags="(@Regression or @DeleteTest) and not @saladTest"   "        
                					        
           P) Implement Maven driven global values into all test, this will help to have dynamic execution of the tests.
           
           Q) Generate reports for Test Execution results.
           	  - Google search for "maven cucumber reporting" and select the "damianszczepanik cucumber reporting" this is the most popular one used and
           	    it is located at url: https://github.com/damianszczepanik/maven-cucumber-reporting.
           	  - Copy the plugin code into the project's pom.xml file. This code will:
           	  		. Download the "maven-reporting-cucumber.jar" file (as indicated in
           	    	  the "<artifactId>" tag.
           	    	. This code include the phase "verify" which is required to be added when running the TestRunner.java from Maven using prompt 
           	    	  command in order to trigger the generation of the "Test Results" report. Example c:mvn test verify  //this is the phase added. 
           	    	  This "verify" phase will be only executed after all Test executions are done. this is compile --> test --> verify.
           	    	. Note: + The Test execution will generate a "Test Results" file in JSON format (in ${project.build.directory}/jsonReports), and this 
           	    	          will be used as input by this "verify" plugin/phase to create the "final Nice formatted" "Test Results" report. 
           	    	        + We have to modify the "TestRunner.java" to indicate generate the JSON results file and in which folder, this is by
           	    	          adding this plugin keyword after the glue keyword:
           	    	                 ,plugin = "json:targe/cucumberReports/hector-cucumber-report.json"
           	    	                 where: json: indicate the format that the report must be generated.
           	    	                        target: is the standard folder where all test related reports are place.
           	    	                        cucumberReports: is a new folder to be created.
           	    	                        hector-cucumber-report.json: is the name given to the json report. 
           	    	        
           	    	. the <inputDirectory> tag is expecting a file in JSON format, this is why it is indicating the "jsonReports" sub-folder in the
           	    	  ${project.build.directory} folder, as follow:
           	    	                   <inputDirectory>${project.build.directory}/jsonReports</inputDirectory>
           	    	  note: ${project.build.directory} points to the "target" folder: " C:\Eclipse\Work_Area\RestAssured_Maven_Cucumber_BDD_Framework_E2E\target"
           	    	  
           	    	. the <outputDirectory> tag indicate folder where the report generated by the verify phase will be placed, in this case:
           	    	  ${project.build.directory}
           	    	
           	    	. Now let's paste the copied plugin code into the pom.xml between the end tag for properties </properties> xxxxx and the
           	    	  beginning dependencies tag <dependencies>.
           	    	. Update the version tag <version> with the version indicated in the github code: 5.4.0 at this time.
           	    	. remove all tags related to classifications:
           	    	      " <classificationDirectory>${project.build.directory}/classifications</classificationDirectory>
                            <classificationFiles>
                                    <!-- supports wildcard or name pattern -->
                                    <param>sample.properties</param>
                                    <param>other.properties</param>
                            </classificationFiles>"
                     . Run the test to verify where the report was generated based on the ${project.build.directory}: mvn test verify
                       it was confirmed that it points to the target foldet: " C:\Eclipse\Work_Area\RestAssured_Maven_Cucumber_BDD_Framework_E2E\target"
                     . After successful execution of the "mvn test verify"
                       + A new folder is created "cucumber-html-reports".
                       + Open the new folder and the "overview-features.html" file contains the "Test Results" report in the nice format. so, in order
                         to view it in a browser tab:
                              * Right click on it --> click on properties
                              * copy the path in the location, "C:\Eclipse\Work_Area\RestAssured_Maven_Cucumber_BDD_Framework_E2E\target\cucumber-html-reports\overview-features.html"
                              * paste it in any browser tab to see how nice the report looks.
                              The report is bases on the Feature and shows the results for each Scenario/Test executed, Steps/validations executed, the duration of each
                              test and validations, 
                              for Scenario/Test: the detail of the status: passed, failed; duration.
                              for Steps/Validations: the detail of the status: passed, failed, skipped, pending, undefined; duration.
                              for the feature: final whole status and duration.
                              The Tags Report: show the whole Scenario with the description in Gherkin and the associated details.
           
           R)    Jenkins: was downloaded from the official website: https://jenkins.io/download and downloaded the "Generic java packge (.war)" into the c:\jenkins folder.
                 To start jenkins: open a CMD prompt, and go to the folder where jenkins was dowloaded and enter the command: "C:\Jenkins>java -jar jenkins.war -httpport=9090" ENTER key
                 - Jenkins server will start running, just wait for the message "Jenkins is fully up and runnig"
                 - To access it, go to a browser and type: http://localhost:8080.
                 New instruction to Define and execute a Jenkins project to run the RestAssured-Maven-Cucumber created project using the Jenkins webPage apps:
                 	+ To create a new Jenkins project, Click on "New Item", select the "Free style project" and provision the name "RestAssuredMavenCucumberFramework" and 
                 	  click the OK button at the bottom.
                 	+ In the General tab, in the Description section click on the "Advance.." button to provide the "path" where our Maven project (or our source code) is 
                 	  located, so we have to check the option "Use Custome Workspace" and provision the path: "C:\Eclipse\Work_Area\RestAssured_Maven_Cucumber_BDD_Framework_E2E"
                 	+ To provision the command to run the our Maven project, go to the "Build" section of the page, click it and indicate open the "add build step" listbox
                 	  and select "Invoke top-level Maven targets" and provision the Maven command we used in the CMD prompt but without the "mvn" in front (because it is
                 	  implicit), to the command will be something like:
                 	  				 test verify      // Execute all Scenarios/Test, no filter executed and trigger the phase to generate the TestResults Report in HTML format.
                 	  				 test             // ONLY Execute all Scenarios/Test, NO filter executed.
                 	  				 test verify -Dcucumber.filter.tags="@GetPlaceTest"    // the verify trigger the phase to generate the TestResults Report in HTML format.
                					 test verify -Dcucumber.filter.tags="(@GetPlaceTest or @DeleteTest) and not @saladTest"
                					 test -Dcucumber.filter.tags="(@AddPlace or @DeleteTest)" //select scenarios having tags @AddPlace or @DeleteTest 
                					 test -Dcucumber.filter.tags="@Regression or @DeleteTest" //select scenarios having tags @Regression or @DeleteTest
                					 test -Dcucumber.filter.tags="@Regression and @GetPlaceTest" //select scenarios having both tags @Regression or @GetPlaceTest
                					 test -Dcucumber.filter.tags="@Regression"   //select scenarios having tags @Regression
                					        "-D" is for indicating that a parameter is going to be indicated.
                					        "cucumber.filter.tags="" " used to override (replace or insert) the "tags" definition in the @CucumberOptions() of the
                					         "TestRunner.java" program.
                					        
                					c:... "test -Dcucumber.options="--tags @GetPlaceTest" " --> ***** DEPRECATED after Cucumber version 6.******
                					        -D is for indicating that a parameter is going to be indicated. 
                					        cucumber.options="--tags @GetPlaceTest" is the parameter and value passed. See notes.
                					*** Note: While testing for learning the use of the "tags" option while running from Maven, it was found out
                					          that the tags IS NOT working because the execution was always driven by what was indicated in the
                					          "tags" active in the "TestRunner.java". The reason is that with Cucumber v6 and onwards you can no longer use
                					           cucumber.options with a command line like string. Instead you'll have to use individual properties:
                                                  " test -Dcucumber.filter.tags="(@Regression or @DeleteTest) and not @saladTest"   "                  	  				 
                 	   
                 	+ Click on Save button.
                 	+ To run the project in Jenkins we just need to click on the "Build Now" button.
                 	+ To filter what @Test to execute we have to Parameterize the Jenkins project by making these changes:
                 		. In the "General" tab, Description section: Check the "This project is Parameterized" checkbox.
                 		. Select "Choice Parameter" as the type of parameter. 
                 			* provision "tags01" in the Name field.
                 			* provsion these choices:
                 			        not @EmptyToRunAll       // this is for selecting execution of all test
									@AddPlaceTest            // Execute all Scenarios with the tag @AddPlaceTest
									@GetPlaceTest
									@DeletePlace
									@Regression              // Execute all Scenarios with the tag @Regression
									@AddPlaceTest or @DeletePlace  // Execute all Scenarios with the ether tag @AddPlaceTest or @DeletePlace.
									@GetPlaceTest and @Regression  // Execute all Scenarios with the both tags @GetPlaceTest and @Regression.
                 		. In the "General" tab, Build section: modify the Maven execution command by adding the created "tag" parameter as follow:
                 		            test verify  -Dcucumber.filter.tags=$"tags01"  
                 		            Note: the $"" indicates that a parameter is used.                 			           
                 	  + NOW to run the project in Jenkins we just need to click on the "Build with Parameters" button instead of the "Build Now" button.
                 
                 Below are the notes from my original installation located in file /Maven-Selenium-app/ZZ_JenkinsInstallationAndTips in Selenium 
                  project: C:\Users\ssshh\Maven-Selenium-app. Maybe some are not applicable now but saved time in rewriting new instruction from Rahul.
                  
                  jenkins is a very important tool for developer and testing, because it is a Continue Integration tool that
was developed mainly for automation of the daily manual commands we issue for everything, like deploying
the code, copying files, etc. Also, assuming we have 500 test in Eclipse, taking 7 hours to run, and instead of running then in 
Eclipse or in Maven manually, we can create a job in Jenkins to trigger automatic execution a 2:00 am.
Jenkins only knows that have to execute some script or command, any type.
Jenkins provide a user friendly environment to view the reports of the automated test execution. this is possible through 
having the URL of the Jenkins Project. In this Jenkins project if we want to execute the command now, we
just have to click the "Build Now" button and to see the result they can click the result button. This
means that having the Jenkins project URL any one can run the automated tests and see the results.

Jenkins runs on it own server, so we need to set up Java and Maven to it. and based on the Java and Maven
version that we indicate/installed Jenkins will run for that indicated version. this means, that if we
have a TestNG version 6, but we want to execute the tests on version 5 (because it is more stable) we can
indicate to Jenkins to use TestNG version 5. So Jenkins runs with the version of its own environment and
this avoid the issues of different version related to the TestNG or Selenium version installed in every
person machine. because all the test cases will always run in the version that we have provide in the
Jenkins environment. *** It is a good practice that the business management see the testing result from
the Jenkins environment by us sharing the Jenkins URL to our project.

INSTALLING Jenkins.
Normally in each company they will have centralized servers where they install Jenkins, so we don't have to install
there, but if its needed we know how to because here we are installing Jenkins in our local host machine:
1- Google: Jenkins download
2- click on the official site download to get to here: https://jenkins.io/download/
3- In local host, we are going to be using Jenkins as window's service, not at hosting the service, so
   we have to go down and click on "Generic Java Package (.war)" for "Long Term Support (LTS) on left
   column.
4- For download: I have created a new c:\Jenkins folder to received the jenkins.war file
5- Open a cmd session and move to the folder where the downloaded jenkins.war is located: cd c:\jenkins folder

6- to start the jenkins server in issue: c:\jenkins> java -jar jenkins.war -httpPort=8080
   could be any free port in the machine, like 8089. Wait until this message is displayed:
             INFO: Completed initialization
  			 Jun 20, 2018 4:29:13 PM hudson.WebAppMain$3 run
			 INFO: Jenkins is fully up and running

7- follow instrutions to get the initial password 7c76c5bccfe541f0bbe4d8a11b5cbbe4 in directory:
   c:\users\ssshhh\.jenkins\secret, paste it in the pop window and click continue
8- Select install all pluggins and click next,
9- when finished: If have created the new userId: hectorAdmin with p a ss wrd: saibaba0
10- in instance configuration I have selected 
	Jenkins URL:  http://localhost:8080
11- Process is completed.
12- Open a new browser windows and user URL: http://localhost:8080/login
13- Use userid: hectorAdmin/saibaba0

14- To configure Jenkins we need these softwares: Maven and Java (Not, we dont need Selenium, TestNg..)
    Maven has an excellent intergration with Jenkins, so that we can use all Maven projects in Jenkins.
    Jenkins has pluggins and commands to work with Maven, so that Jenkins can access all Maven commands
    and run then on behalf of us.
    To setup Maven and Java, click on "Manage Jenkins" link.
15- click on the "Global tools configuration" link.
    click on Add JDK.
    provide the name: jdk1.8.0_201
    provide JAVA_HOME: C:\Program Files\Java\jdk1.8.0_171
	On Maven panel
	provide the name: Maven-3.6.3
	provide MAVEN_HOME: C:\Maven\apache-maven-3.6.3
16- Click on Save button.

CONNECTING A MAVEN PROJECT INTO JENKINS ENVIRONMENT.
1- Copy the Maven Folder containing ALL the code for the Maven's project (Maven-Selenium-app, in c:\users\ssshh\) to the 
   Jenkins directory $JENKINS_HOME (c:\users\ssshh\.jenkins. Now Jenkins has all the code of the Maven
   project in its environment and directly available for execution in Jenkins.
   Note: if I have a Postman code, I also have to copy it first to Jenkins so Jenkins can execute it.
1.1 Copy the pom.xml and all others .xml files from Maven to this same directory   
    
2-In Jenkins main page click on "New Item" link to create a new Jenkins Job/Project.
3- Enter the Item/Job/Project name: HectorFirstMavenProject
4- Select the "Freestyle Projet" option and click Ok button.
5- To provide the location of the Maven project code in Jenkins environment, In the General tab.
	5.1- Click on the "Advance.." button to show more option.
	5.2- Click on the "Use Custom Workspace" option 
	5.3- In the directory box: Provide the directory of the Maven project in Jenkins, this is:
	     - For Maven: ${JENKINS_HOME}/Maven-Selenium-app
	                  This ${JENKINS_HOME} will execute and get the content of the JENKINS_HOME environment variable. 
	     - For SOAPUI indicate the "testRunner" path directory: C:\Program Files\SmartBear\SoapUI-5.4.0\bin
	     
	Note-1: For companies having the code in Github or Subversion server, then we have to select the 
	      corresponding option in section "Source Code Management", instead of the "Advance..", so 
	      for execution, Jenkins download the code from these webserver (Github or Subversion).
	      Because, in this case, we have not specify the use of any of this webserver, Jenkins will be 
	      using the "Custom Workspace" defined here.
	      
	Note-2: If we want to automatically trigger the execution of this project based on some schedule,
	      then we can use the section "Build Triggers" here we can use:
	      - "Build Periodically" option to define the schedule we want to Job/build/project to run.
	      - "Build after other projects are build" option to trigger execution of this job/build/project
	        for example, after deploying a new build code to System Test then running an automatic 
	        Regresion or Smoke test, etc.     
6- To provide the command to execute the Maven Test project:
	6.1- Click on the Build link.
	6.2- In "Adding Steps" select:
	     - For Maven: "Invoke top-level Maven Targets" option 
	     - For SOAPUI: "Execute Windows batch commnad"
    6.2.1 insert step to Delete any previous *.xml:
        For SOAPUI: del C:\SOAP_UI\Reports\*.xml 
	     
	- FOR MAVEN:     
	6.3- Select the Maven version that we configured before in Global Tools.
	6.4- In the Goals enter the Maven command we want to execute: test -PRegression 
	     OR  test 
	     OR  test -PSmoke  (for execution using PROFILED test Suite for Smoke test)
	- FOR SOAPUI enter below command in the command panel:
	6.5- testrunner.bat -sAutomaationGrovvyTestSuite -cGroovyScriptTestCase -r -a -j -J -f C:\SOAP_UI\Reports -I C:\SOAP_UI\04AutomationWithGroovySOAPProject-soapui-project.xml
	  	                    here -s is the TestSuite. (xxx or all) 
  	                         -c is the test case. (xxx or all)
  	                         -r indicate generate Report
  	                         -j indicate generate report in JUnit format.
  	                         -f indicate the path of the report to be created: C:\SOAP_UI\Reports.  Note: the *.xml file created here then will be copied to folder 
  	                                  C:\Program Files\SmartBear\SoapUI-5.4.0\bin\reports (note the folder "reports" was added by me to in order to be able to 
  	                                  provision this **/TEST-AutomaationGrovvyTestSuite.xml in the "Test Report XMLs" field later in the configuration.
                             -I indicate continue execution if an error was found, this allows the Jenkins report graph displays the test in error.
  	                         - Last is the path and name of the project: C:\SOAP_UI\04AutomationWithGroovySOAPProject-soapui-project.xml

    6.5.1 ADDING RENAME STEP: 
    In case we have more than one steps executing (see 6.5) different testCases in the same testSuite we have to rename the xml file 
    in the "reports" folder adding the date-Time Stamp so that we have multiple .xml file for the same testSuite, INSERT below command:
      ren C:\SOAP_UI\Reports\TEST-FirstTestSuite.xml TEST-FirstTestSuite_%date:~-4%%date:~4,2%%date:~7,2%%time:~0,2%%time:~3,2%%time:~6,2%.xml
	
	6.6- Add another step to copy the *.xml file created in c:\SOAP_UI\Reports folder to the ....\reports folder under the workspace folder, for this:
	     In "Adding Steps" select:
	       - For SOAPUI: "Execute Windows batch commnad"
	     
	6.7- FOR SOAPUI enter below command in the command panel:
	      copy C:\SOAP_UI\Reports\*.xml "C:\Program Files\SmartBear\SoapUI-5.4.0\bin\reports" /Y
	          
7- Clik on Save buttton. And we have successfully created our first Jenkins project!!!!!

To run the job/build/project from the Jenkins page:
1- Click on the left side menu "Build Now" option 	
2- The Execution is displayed in the "Build History" panel with a execution number #xxx
3- Wen execution finishes, click on the link created to see the results.
4- click on the "Console Output" to see the result in the console.     

MODIFYING THE PROJECT TO INDICATE RUNNING A DIFFERENT MAVEN COMMAND
1- On jenkins main page, on left side menu click on "Configure" option
2- In the Build section, update the Maven command as neeed.

INTEGRATING The TestNG format Output/Result REPORT AFTER RUNNING WITH JENKINS.
- Afte running with Jenkins, if we go to Eclipse and Refresh (PF5 Key) and opening the "Target' folder
  we will find the new folder "sunfire reports", opening it we will find the testng-results.xml file, this
  file contains all the execution result in xml format and is going to be used by Jenkins to displays 
  the result in the Webbrowser format. to get this we need to configure the TestNG report plugin
  by following below steps:
1- Install the TestNG pluggin in Jenkins:
2- Go to the Jenkins Dashboard.
3- In the left menu click on the "Manage Jenkins" link
4- Click on "Manage Plugins" link
5- Click on the "Available" tab 
6- Search/filter for/by "testng" or "JUnit" in the top righ filter    
7- check on the "TestNG Results" "JUnit Plugin" and click on the "Install without restart" button.
   Note: JUnit plugin was already installed.
8- verify success message.
9- click on "Go back to the top page" link.

VERIFY THAT THE TESTNG PLUGIN and/or JUnit plugin (for SOAPUI) IS NOW ATTACHED TO THE Jenkins project:
1- Go to the Jenkins project.
2- On the left menu, click on "Configure" link.
3- Go to the "Post-Build Actions" section
4- click on the "Post-Build Actions" list box and select the "Publish TestNG Results" or "Publish JUnit Test Result Report" option.
5- Verify that:
   - For Maven/TestNG: the field "TestNG XML report pattern" is automatically populated with the .xml file
        in the "Target" new folder "sunfire reports": **/testng-results.xml
   - For SOAPUI/JUnit: In the "Test Report XMLs" field provision this
          **/TEST-AutomaationGrovvyTestSuite.xml   OR 
          **/reports/TEST-AutomaationGrovvyTestSuite.xml, **/reports/TEST-FirstTestSuite.xml  OR
          **/reports/*.xml
          These files are included in the folder
                      where the xml report is created.  Note from website: "* only matches any files in workspace directory/folder, if the artifacts you want to 
                      archive is in some subdirectories, you need the pattern like **/*.xml to match all files in all subdirectories with postfix .xml.
                      The workspace directory/folder is:
                         - For SOAPUI testRunner: C:\Program Files\SmartBear\SoapUI-5.4.0\bin
                         - For Maven: ${JENKINS_HOME}/Maven-Selenium-app "      
     
6- Click on Save button.
7- Now the TestNG Results report will be generated every time the project runs, either by "Build Now" or 
   scheduled.
   
SCHEDULING A JENKINS JOB/PROJECT.
1- Being in the project, On the left side menu click on Configure
2- Go to the "Build Trigger" section and click on "Build periodically"
3- Use below format to populate the shedule panel: this is used to define the scheduling of a Jenkins job to run on a specific time:
	1- MINUTES - an integer number or '*' for: specific Minute in one hour (0-59)
	2- HOURS - an integer number or '*' for: specific Hour in one day (0-23)
	3- DAYMONTH - an integer number or '*' for: Specific Day in a month (1-31)
	4- MONTH - an integer number or '*' for: Specific Month in year (1-12)
	5- DAYWEEK - an integer number or '*' for: Specific Day of the week (0-7) where 0 and 7 are sunday.
Since a few versions, Jenkins added a new parameter "H" to allow periodically scheduled tasks to 
produce an even load on the system, the symbol H (for 'hash') should be used wherever possible,
for example using 0 0 * * * for running a 30 daily jobs will cause a large spike at midnight. In
contrast using    H H * * * would still execute each job once a day but not all at the same time
helping to better use of limiting resources.
Note also that the H symbol can be thought of as a random value over a range, but it actually is
a hash of the job name, not a random function, so that the value remains stable for any given 
project.
Example 1: H H(3-4) * * * A job which runs every Day of the week, every Month in a year, every Day 
in a month, at a time between 3-4 am in the morning, at any minute.
       
Example 2: H(30-45) 14 * * * A job which runs every Day of the week, every Month in a year, every Day 
in a month, at a 2 pm in the afternoon, between 30 - 45 minutes.

Example 3: */5 * * * * If we want to trigger the build every 5 minutes, this will fo the job.
Example 4: 0 8 * * *  this will trigger the build every day at 8 am, 00  minutes.

4- Click on the Save button.
                   
            
           S)
           
           T)
           
           U)